/*********************************************************************\
*                                                                     *
* epolys.js                                          by Mike Williams *
* updated to API v3                                  by Larry Ross    *
*                                                                     *
* A Google Maps API Extension                                         *
*                                                                     *
* Adds various Methods to google.maps.Polygon and google.maps.Polyline *
*                                                                     *
* .Contains(latlng) returns true is the poly contains the specified   *
*                   GLatLng                                           *
*                                                                     *
* .Area()           returns the approximate area of a poly that is    *
*                   not self-intersecting                             *
*                                                                     *
* .Distance()       returns the length of the poly path               *
*                                                                     *
* .Bounds()         returns a GLatLngBounds that bounds the poly      *
*                                                                     *
* .GetPointAtDistance() returns a GLatLng at the specified distance   *
*                   along the path.                                   *
*                   The distance is specified in metres               *
*                   Reurns null if the path is shorter than that      *
*                                                                     *
* .GetPointsAtDistance() returns an array of GLatLngs at the          *
*                   specified interval along the path.                *
*                   The distance is specified in metres               *
*                                                                     *
* .GetIndexAtDistance() returns the vertex number at the specified    *
*                   distance along the path.                          *
*                   The distance is specified in metres               *
*                   Returns null if the path is shorter than that      *
*                                                                     *
* .Bearing(v1?,v2?) returns the bearing between two vertices          *
*                   if v1 is null, returns bearing from first to last *
*                   if v2 is null, returns bearing from v1 to next    *
*                                                                     *
*                                                                     *
***********************************************************************
*                                                                     *
*   This Javascript is provided by Mike Williams                      *
*   Blackpool Community Church Javascript Team                        *
*   http://www.blackpoolchurch.org/                                   *
*   http://econym.org.uk/gmap/                                        *
*                                                                     *
*   This work is licenced under a Creative Commons Licence            *
*   http://creativecommons.org/licenses/by/2.0/uk/                    *
*                                                                     *
***********************************************************************
*                                                                     *
* Version 1.1       6-Jun-2007                                        *
* Version 1.2       1-Jul-2007 - fix: Bounds was omitting vertex zero *
*                                add: Bearing                         *
* Version 1.3       28-Nov-2008  add: GetPointsAtDistance()           *
* Version 1.4       12-Jan-2009  fix: GetPointsAtDistance()           *
* Version 3.0       11-Aug-2010  update to v3                         *
*                                                                     *
\*********************************************************************/
// === first support methods that don't (yet) exist in v3
google.maps.LatLng.prototype.distanceFrom = function(newLatLng) {
  var EarthRadiusMeters = 6378137.0; // meters
  var lat1 = this.lat();
  var lon1 = this.lng();
  var lat2 = newLatLng.lat();
  var lon2 = newLatLng.lng();
  var dLat = (lat2-lat1) * Math.PI / 180;
  var dLon = (lon2-lon1) * Math.PI / 180;
  var a = Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(lat1 * Math.PI / 180 ) * Math.cos(lat2 * Math.PI / 180 ) *
    Math.sin(dLon/2) * Math.sin(dLon/2);
  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  var d = EarthRadiusMeters * c;
  return d;
}

google.maps.LatLng.prototype.latRadians = function() {
  return this.lat() * Math.PI/180;
}

google.maps.LatLng.prototype.lngRadians = function() {
  return this.lng() * Math.PI/180;
}

// === A method for testing if a point is inside a polygon
// === Returns true if poly contains point
// === Algorithm shamelessly stolen from http://alienryderflex.com/polygon/ 
google.maps.Polygon.prototype.Contains = function(point) {
  var j=0;
  var oddNodes = false;
  var x = point.lng();
  var y = point.lat();
  for (var i=0; i < this.getPath().getLength(); i++) {
    j++;
    if (j == this.getPath().getLength()) {j = 0;}
    if (((this.getPath().getAt(i).lat() < y) && (this.getPath().getAt(j).lat() >= y))
    || ((this.getPath().getAt(j).lat() < y) && (this.getPath().getAt(i).lat() >= y))) {
      if ( this.getPath().getAt(i).lng() + (y - this.getPath().getAt(i).lat())
      /  (this.getPath().getAt(j).lat()-this.getPath().getAt(i).lat())
      *  (this.getPath().getAt(j).lng() - this.getPath().getAt(i).lng())<x ) {
        oddNodes = !oddNodes
      }
    }
  }
  return oddNodes;
}

// === A method which returns the approximate area of a non-intersecting polygon in square metres ===
// === It doesn't fully account for spherical geometry, so will be inaccurate for large polygons ===
// === The polygon must not intersect itself ===
google.maps.Polygon.prototype.Area = function() {
  var a = 0;
  var j = 0;
  var b = this.Bounds();
  var x0 = b.getSouthWest().lng();
  var y0 = b.getSouthWest().lat();
  for (var i=0; i < this.getPath().getLength(); i++) {
    j++;
    if (j == this.getPath().getLength()) {j = 0;}
    var x1 = this.getPath().getAt(i).distanceFrom(new google.maps.LatLng(this.getPath().getAt(i).lat(),x0));
    var x2 = this.getPath().getAt(j).distanceFrom(new google.maps.LatLng(this.getPath().getAt(j).lat(),x0));
    var y1 = this.getPath().getAt(i).distanceFrom(new google.maps.LatLng(y0,this.getPath().getAt(i).lng()));
    var y2 = this.getPath().getAt(j).distanceFrom(new google.maps.LatLng(y0,this.getPath().getAt(j).lng()));
    a += x1*y2 - x2*y1;
  }
  return Math.abs(a * 0.5);
}

// === A method which returns the length of a path in metres ===
google.maps.Polygon.prototype.Distance = function() {
  var dist = 0;
  for (var i=1; i < this.getPath().getLength(); i++) {
    dist += this.getPath().getAt(i).distanceFrom(this.getPath().getAt(i-1));
  }
  return dist;
}

// === A method which returns the bounds as a GLatLngBounds ===
google.maps.Polygon.prototype.Bounds = function() {
  var bounds = new google.maps.LatLngBounds();
  for (var i=0; i < this.getPath().getLength(); i++) {
    bounds.extend(this.getPath().getAt(i));
  }
  return bounds;
}

// === A method which returns a GLatLng of a point a given distance along the path ===
// === Returns null if the path is shorter than the specified distance ===
google.maps.Polygon.prototype.GetPointAtDistance = function(metres) {
  // some awkward special cases
  if (metres == 0) return this.getPath().getAt(0);
  if (metres < 0) return null;
  if (this.getPath().getLength() < 2) return null;
  var dist=0;
  var olddist=0;
  for (var i=1; (i < this.getPath().getLength() && dist < metres); i++) {
    olddist = dist;
    dist += this.getPath().getAt(i).distanceFrom(this.getPath().getAt(i-1));
  }
  if (dist < metres) {
    return null;
  }
  var p1= this.getPath().getAt(i-2);
  var p2= this.getPath().getAt(i-1);
  var m = (metres-olddist)/(dist-olddist);
  return new google.maps.LatLng( p1.lat() + (p2.lat()-p1.lat())*m, p1.lng() + (p2.lng()-p1.lng())*m);
}

// === A method which returns an array of GLatLngs of points a given interval along the path ===
google.maps.Polygon.prototype.GetPointsAtDistance = function(metres) {
  var next = metres;
  var points = [];
  // some awkward special cases
  if (metres <= 0) return points;
  var dist=0;
  var olddist=0;
  for (var i=1; (i < this.getPath().getLength()); i++) {
    olddist = dist;
    dist += this.getPath().getAt(i).distanceFrom(this.getPath().getAt(i-1));
    while (dist > next) {
      var p1= this.getPath().getAt(i-1);
      var p2= this.getPath().getAt(i);
      var m = (next-olddist)/(dist-olddist);
      points.push(new google.maps.LatLng( p1.lat() + (p2.lat()-p1.lat())*m, p1.lng() + (p2.lng()-p1.lng())*m));
      next += metres;    
    }
  }
  return points;
}

// === A method which returns the Vertex number at a given distance along the path ===
// === Returns null if the path is shorter than the specified distance ===
google.maps.Polygon.prototype.GetIndexAtDistance = function(metres) {
  // some awkward special cases
  if (metres == 0) return this.getPath().getAt(0);
  if (metres < 0) return null;
  var dist=0;
  var olddist=0;
  for (var i=1; (i < this.getPath().getLength() && dist < metres); i++) {
    olddist = dist;
    dist += this.getPath().getAt(i).distanceFrom(this.getPath().getAt(i-1));
  }
  if (dist < metres) {return null;}
  return i;
}

// === A function which returns the bearing between two vertices in decgrees from 0 to 360===
// === If v1 is null, it returns the bearing between the first and last vertex ===
// === If v1 is present but v2 is null, returns the bearing from v1 to the next vertex ===
// === If either vertex is out of range, returns void ===
google.maps.Polygon.prototype.Bearing = function(v1,v2) {
  if (v1 == null) {
    v1 = 0;
    v2 = this.getPath().getLength()-1;
  } else if (v2 ==  null) {
    v2 = v1+1;
  }
  if ((v1 < 0) || (v1 >= this.getPath().getLength()) || (v2 < 0) || (v2 >= this.getPath().getLength())) {
    return;
  }
  var from = this.getPath().getAt(v1);
  var to = this.getPath().getAt(v2);
  if (from.equals(to)) {
    return 0;
  }
  var lat1 = from.latRadians();
  var lon1 = from.lngRadians();
  var lat2 = to.latRadians();
  var lon2 = to.lngRadians();
  var angle = - Math.atan2( Math.sin( lon1 - lon2 ) * Math.cos( lat2 ), Math.cos( lat1 ) * Math.sin( lat2 ) - Math.sin( lat1 ) * Math.cos( lat2 ) * Math.cos( lon1 - lon2 ) );
  if ( angle < 0.0 ) angle  += Math.PI * 2.0;
  angle = angle * 180.0 / Math.PI;
  return parseFloat(angle.toFixed(1));
}

// === Copy all the above functions to GPolyline ===
google.maps.Polyline.prototype.Contains             = google.maps.Polygon.prototype.Contains;
google.maps.Polyline.prototype.Area                 = google.maps.Polygon.prototype.Area;
google.maps.Polyline.prototype.Distance             = google.maps.Polygon.prototype.Distance;
google.maps.Polyline.prototype.Bounds               = google.maps.Polygon.prototype.Bounds;
google.maps.Polyline.prototype.GetPointAtDistance   = google.maps.Polygon.prototype.GetPointAtDistance;
google.maps.Polyline.prototype.GetPointsAtDistance  = google.maps.Polygon.prototype.GetPointsAtDistance;
google.maps.Polyline.prototype.GetIndexAtDistance   = google.maps.Polygon.prototype.GetIndexAtDistance;
google.maps.Polyline.prototype.Bearing              = google.maps.Polygon.prototype.Bearing;

/* end epolys.js */

function CMMRM_RouteModel(data, waypointsString, locations, icon, polyline) {
	this.polyline = polyline;
	this.data = data;
	this.waypointsString = (typeof waypointsString == 'string' ? waypointsString : '');
	this.waypointsCoords = [];
	this.waypoints = [];
	this.decodeWaypoints();
	
	this.waypointsCoordsString = '';
	this.commaWaypoints();
	
	this.locations = [];
	this.data.latlng = [];
	this.data.latlngStr = '';
	this.data.latlngStrArr = [];
	if(typeof this.data.path_waypoints !== 'undefined'){
		var datac;
		// If Travel mode is "walking"
		if ( typeof this.data.main_path_data !== 'undefined' && this.data.main_path_data.length > 0 ){
			try {
				datac = JSON.parse(this.data.main_path_data);
				for(var i = 0; i < datac.length; ++i){
					this.data.latlng.push(new google.maps.LatLng(datac[i]['lat'], datac[i]['lng']));
				}
			}
			catch(err) {
				console.log('wrong JSON data')
			}
			// Else travel mode is "straight-line"
		} else {
			try {
				datac = this.data.path_waypoints;
				for(var i = 0; i < datac.length; ++i){
					this.data.latlng.push(new google.maps.LatLng(datac[i][0], datac[i][1]));
				}
			}
			catch(err) {
				console.log('wrong JSON data')
			}
		}

	}
	this.addLocations(locations);
}

CMMRM_RouteModel.prototype.addLocations = function(locations) {
	if (typeof locations != 'undefined') {
		for (var i=0; i<locations.length; i++) {
			
			if (typeof this.polyline !== 'undefined' && this.polyline != '') {
				var distance_ol = parseFloat(locations[i].distance * 1000);
				var latng_ol = this.polyline.GetPointAtDistance(distance_ol);
				locations[i].lat = latng_ol.lat();
				locations[i].lng = latng_ol.lng();
			}
			
			this.addLocation(locations[i]);
		}
	}
};

CMMRM_RouteModel.prototype.addLocation = function(locationData) {
	var locationModel = new CMMRM_LocationModel(locationData, this);
	var that = this;
	this.locations.push(locationModel);
	jQuery(this).trigger('RouteModel:addLocation', {locationData: locationData, locationModel: locationModel});
	jQuery(locationModel).bind('LocationModel:remove', function() {
		that.removeLocationByModel(this);
	});
	return locationModel;
};

CMMRM_RouteModel.prototype.removeLocationByIndex = function(index) {
	var removed = this.locations.splice(index, 1);
	return (removed.length == 1);
};

CMMRM_RouteModel.prototype.removeLocationByModel = function(obj) {
	for (var i=0; i<this.locations.length; i++) {
		if (this.locations[i] === obj) {
			return this.removeLocationByIndex(i);
		}
	}
	return false;
};

CMMRM_RouteModel.prototype.addWaypoints = function(waypoints) {
	var that = this;
	for (var i=0; i<waypoints.length; i++) {
		this.addWaypoint(waypoints[i]);
	}
	return this;
};

CMMRM_RouteModel.prototype.removeWaypointByIndex = function(index) {
	var removed = this.waypointsCoords.splice(index, 1);
	return (removed.length == 1);
};

CMMRM_RouteModel.prototype.removeWaypointByModel = function(obj) {
	for (var i=0; i<this.waypoints.length; i++) {
		if (this.waypoints[i] === obj) {
			return this.removeWaypointByIndex(i);
		}
	}
	return false;
};

CMMRM_RouteModel.prototype.commaWaypoints = function() {
	if (typeof this.waypointsString == 'string') {
		this.waypointsCoordsString = this.waypointsString;
	} else {
		this.waypointsCoordsString = '';
	}
	return this;
};

CMMRM_RouteModel.prototype.decodeWaypoints = function() {
	if (typeof this.waypointsString == 'string') {
		this.waypointsCoords = google.maps.geometry.encoding.decodePath(this.waypointsString);
	} else {
		this.waypointsCoords = [];
	}
	return this;
	//return this.addWaypoints(coords);
};

CMMRM_RouteModel.prototype.addWaypoint = function(waypointData, index) {
	if (Object.prototype.toString.call(waypointData) == '[object Array]') {
		//waypointData = [waypointData.lat(), waypointData.lng()];
		waypointData = new google.maps.LatLng(waypointData[0], waypointData[1]);
	}
	
	if (typeof index == 'undefined') {
		index = this.waypointsCoords.length;
		this.waypointsCoords.push(waypointData);
	} else {
		this.waypointsCoords.splice(index, 0, waypointData);
	}
	
	jQuery(this).trigger('RouteModel:addWaypoint', {waypointData: waypointData});
	
	return this;
};

CMMRM_RouteModel.prototype.getTravelMode = function() {
	return this.data.travelMode;
};

CMMRM_RouteModel.prototype.setTravelMode = function(mode) {
	var old = this.data.travelMode;
	this.data.travelMode = mode;
	jQuery(this).trigger('RouteModel:setTravelMode', {old: old, travelMode: mode});
	return this;
};

CMMRM_RouteModel.prototype.getLocations = function() {
	return this.locations;
};

CMMRM_RouteModel.prototype.getWaypoints = function() {
	return this.waypoints;
};

CMMRM_RouteModel.prototype.getWaypointsString = function() {
	return this.waypointsString;
};

CMMRM_RouteModel.prototype.setWaypointsString = function(val) {
	var old = this.waypointsString;
	this.waypointsString = val;
	jQuery(this).trigger('RouteModel:setWaypointsString', {old: old, waypointsString: val});
	return this;
};

CMMRM_RouteModel.prototype.getWaypointsCoords = function() {
	return this.waypointsCoords;
};

CMMRM_RouteModel.prototype.getWaypointsGoogleLatLng = function() {
	var coords = [];
	for (var i=0; i<this.waypoints.length; i++) {
		coords.push(this.waypoints[i].getGoogleLatLng());
	}
	return coords;
};

CMMRM_RouteModel.prototype.getWaypointsCoordsString = function() {
	if(this.waypointsCoordsString != '') {
		return this.waypointsCoordsString;
	} else {
		return this.data.overviewPath;
	}
};

CMMRM_RouteModel.prototype.getPolylineString = function() {
	return this.data.overviewPath;
};

CMMRM_RouteModel.prototype.setPolylineString = function(str) {
	var old = this.data.overviewPath;
	this.data.overviewPath = str;
	jQuery(this).trigger('RouteModel:setPolylineString', {old: old, polylineString: str});
	return this;
};

CMMRM_RouteModel.prototype.setLatLongList = function(str) {
	this.data.latlng = str;
	return this;
};

CMMRM_RouteModel.prototype.getPolylineCoords = function() {
	var str = this.getPolylineString();
	if (str) {
		return google.maps.geometry.encoding.decodePath(str);
	} else {
		return [];
	}
};

CMMRM_RouteModel.prototype.getPathColor = function() {
	return (this.data.pathColor ? this.data.pathColor : '#3377FF');
};

CMMRM_RouteModel.prototype.getSlopeDownwardColor = function() {
	return (this.data.slopeDownwardColor ? this.data.slopeDownwardColor : '#3377FF');
};

CMMRM_RouteModel.prototype.getSlopeUpwardColor = function() {
	return (this.data.slopeUpwardColor ? this.data.slopeUpwardColor : '#3377FF');
};

CMMRM_RouteModel.prototype.showDirectionalArrows = function() {
	return this.data.showDirectionalArrows;
};

CMMRM_RouteModel.prototype.getIcon = function() {
	return null;
};

CMMRM_RouteModel.prototype.getName = function() {
	return this.data.name;
};

CMMRM_RouteModel.prototype.getIcon = function() {
	return this.data.icon;
};

CMMRM_RouteModel.prototype.getLocationInfo = function() {
	return this.data.infoContent;
};

CMMRM_RouteModel.prototype.getBounds = function() {
	var coords = [];
	
	// Add waypoints
	/*
	var waypoints = this.getWaypoints();
	for (var i=0; i<waypoints.length; i++) {
		coords.push(waypoints[i].getPosition());
	}
	*/
	
	// Add locations
	var locations = this.getLocations();
	for (var i=0; i<locations.length; i++) {
		coords.push(locations[i].getPosition());
	}
	
	// Add polyline
	var polyline = this.getPolylineCoords();
	for (var i=0; i<polyline.length; i++) {
		coords.push(polyline[i]);
	}
	
	// Add default lat lng
	var latLng = this.getGoogleLatLng();
	if (latLng) {
		coords.push(latLng);
	}
	
	return coords;
};

CMMRM_RouteModel.prototype.setRouteParam = function(name, val) {
	var old = this.data[name];
	this.data[name] = val;
	jQuery(this).trigger('RouteModel:setRouteParam', {name: name, old: old, value: val});
	return this;
};

CMMRM_RouteModel.prototype.getRouteParam = function(name) {
	return this.data[name];
};

CMMRM_RouteModel.prototype.updateWaypointsString = function() {
	//var waypoints = this.getWaypointsCoords();
	if (google && google.maps && google.maps.geometry && google.maps.geometry.encoding) {
		var coords = this.getWaypointsCoords();
		/*
		for (var i=0; i<waypoints.length; i++) {
			coords.push(new google.maps.LatLng(waypoints[i].getLat(), waypoints[i].getLng()));
		}
		*/
		//console.log(coords);
		var path =  google.maps.geometry.encoding.encodePath(coords);
		//console.log(path);
		this.setWaypointsString(path);
	}
};

CMMRM_RouteModel.prototype.getGoogleLatLng = function() {
	//console.log(this.data.lat, this.data.long);
	if (this.data.lat && this.data.long) {
		return new google.maps.LatLng(this.data.lat, this.data.long);
	}
};

CMMRM_RouteModel.prototype.getGoogleLatLngStr = function() {
	//console.log(this.data.lat, this.data.long);
	if (this.data.lat && this.data.long) {
		return this.data.lat+"|"+this.data.long;
	}
};

CMMRM_RouteModel.prototype.showPathOutline = function() {
	return this.data.showPathOutline;
}

CMMRM_RouteModel.prototype.isEmpty = function() {
	return (this.locations.length == 0 && this.waypointsCoords.length == 0);
};

CMMRM_RouteModel.prototype.isSlopesShowingEnabled = function() {
	return this.data.isSlopesShowingEnabled;
};

CMMRM_RouteModel.prototype.getSlopeMinValue = function() {
	return this.data.slopeMinValue;
};

CMMRM_RouteModel.prototype.getSlopeMinWidth = function() {
	return this.data.slopeMinWidth;
};

CMMRM_RouteModel.prototype.getStartingPointCoords = function() {
	return this.getGoogleLatLng();
	/*
	var pathCoords = this.getWaypointsCoords();
	if ('path' == CMMRM_Map_Settings.startingPointMarker && pathCoords && pathCoords.length > 0) {
		return pathCoords[0];
	}
	var locations = this.getLocations();
	if (locations && locations.length > 0) {
		return locations[0].getGoogleLatLng();
	}
	*/
};